% top-level definitions go into systemdict
/#! {{currentfile 128 string readline exch pop {exit} if} loop} bind def
/# /#! load def  % also enable # comments
/.silent -112 def  % gs_error_silent in base/gserrors.h

/forthdict 1024 dict def
forthdict begin
  % add some helpful words from FORTH, starting with `words`
  /dictwords {  % dict -
    % print to stdout all the words (keys) in the dictionary
    {pop cvx ==only ( ) =only} forall () =
  } bind def
  /words {  % -
    % print to stdout all words from all dictionaries, like FORTH
    countdictstack array dictstack {dictwords} forall
  } bind def
  /bye /quit load def  % alias Forth 'bye' to ps 'quit'
  /see {  % *not* prefix like Forth; use as `/someword see`
    {mark exch load dup mark exch ===} stopped {cleartomark ==} {pop} ifelse
    cleartomark  % necessary in case `load` was unrecognized
  } bind def
end  % forthdict

/casperdict 1024 dict def
casperdict begin
  % add some generally useful words without polluting systemdict
  /topdown {  % -
    % changes behavior of interpreter to allow topdown design
    % instead of causing /undefined errors, lets you run program at every
    % phase of development, showing a placeholder for undefined words.
    errordict begin
      /undefined {
        (\(/) print =only ( not yet defined\) ) print
      } bind def
    end
  } bind def
  /alias {  % /currentname /newname -
    % alias currentname to newname
    exch load def
  } bind def
  /strlen {  % anystring - strlen  % length to first null (\000)
    % if no nulls, entire length of string (same as `length`)
    (\000) search {3 1 roll pop pop length} {length} ifelse
  } bind def
  /append {  % stringbuffer string - combined
    % add (concatenate) string to buffer without shortening buffer
    % (a\000\000) (b) append -> (ab\000)
    1 index dup strlen  % offset to first empty place in buffer
    % stack now: buffer string buffer offset
    3 2 roll putinterval
  } bind def
  /strtruncate {  % stringbuffer - string
    % remove trailing nulls at end of stringbuffer
    0 1 index strlen getinterval
  } bind def
  /stradd {  % string1 string2 - combined
    % add (concatenate) two strings: (a) (b) stradd -> (ab)
    2 copy strlen exch strlen add string  % make new empty string
    3 2 roll append exch append
  } bind def
  /strmul {  % string multiplier - string
    % multiply a string as does Python: (a) 5 strmul -> (aaaaa)
    1 index strlen 1 index mul string  % string multiplier buffer
    exch {1 index append} repeat
    exch pop
  } bind def
  /add {  % redefine add to include stradd
    {add} stopped {stradd} if
  } bind def
  /mul {  % redefine mul to include strmul
    {mul} stopped {strmul} if
  } bind def
  /truncate {  % redefine truncate to include strtruncate
    {truncate} stopped {strtruncate} if
  } bind def
  /strcopy {  % true copy as opposed to a reference
    dup length string copy
  } bind def
  /add /+ alias  % allow use of `+` for `add`
  /sub /- alias  % allow use of `-` for `sub`
  /mul /* alias  % allow use of `*` for `mul`
  % cannot use `/` for `div`, nor `//` for `idiv`, until we hijack the parser
  % for the same reason we cannot use `%` for `mod`
  /reversed {  % for strings and arrays
    % make sure to make a copy with strcopy if you don't want to mess
    % with the original
    dup length 1 - dup 1 + 2 idiv 1 - 0 1 3 -1 roll {  % array length-1 control
      % e.g. abcxyz 5 0
      %(pstack at start of `for` loop, e.g. abcxyz 5 0:) = pstack
      3 copy 3 copy - get 4 1 roll  % abcxyz 5 0 z abcxyz 5 0
      %(pstack after first get, e.g. abcxyz 5 0 z abcxyz 5 0:) = pstack
      exch pop get  % abcxyz 5 0 z a
      %(should be e.g. abcxyz 5 0 z a:) = pstack
      3 index 3 index - exch 5 index 3 1 roll put
      %(should be e.g. abcxya 5 0 z:) = pstack
      3 index 3 1 roll put  % zbcxya 5
      %(should be e.g. zbcxya 5:) = pstack
    } for pop
  } bind def
  %(languagelevel: ) print /languagelevel where {pop languagelevel} {1} ifelse =
  %(version: ) print version =
  /os 16 dict def
  os begin  % os attributes for GNU/Linux assumed
    /path null def  % fill in later with posixpath
    /name (posix) def
    /curdir (.) def
    /pardir (..) def
    /sep (/) def
    /extsep (.) def
    /altsep (null) def
    /pathsep (:) def
    /linesep (\n) def
    /devnull (/dev/null) def
  end  % os
  /posixpath 16 dict def
  posixpath begin
    % path functions expected to work on posix (and URL paths)
    /split {  % pathspec - dirspec namespec; e.g. /path/to/xyz.ps
      reversed os /sep get search  % ot/htap/ / sp.zyx
        {exch pop reversed exch reversed exch}
        {reversed () exch}
      ifelse
      (pstack after posixpath.split:) = pstack
    } bind def
    /splitext {  % pathspec.ext - pathspec .ext
      % NOTE that this won't work with, e.g. /path/to.some/filewithnoext,
      % it will return /path/to .some/filewithnoext
      % so, one should always `split` before `splitext`
      reversed os /extsep get search  % zyx/ot/htap/ . sp
        {reversed + exch reversed exch}  % /path/to/xyz .ps
        {reversed ()}  % pathwithnoext ''
      ifelse
      (pstack after posixpath.splitext:) = pstack
    } bind def
  end  % posixpath
  os /path posixpath put
  % NOTE: remember that `argv` is *not* defined at this point! `casper` is
  % run at processing of `-C`, and a script is run only after processing `--`.
  /scriptname {
    argv 0 get strcopy os /path get dup /split get 3 -1 roll exch exec
    %(scriptname after split:) = pstack
    %(argv after split:) = argv ==
    exch pop exch /splitext get exec
    %(scriptname after splitext:) = pstack
    %(argv after splitext:) argv ==
    pop
    (stack after scriptname:) = pstack
  } bind def
end  % casperdict

/casper {  % -
  % initialize for programming with casper extensions
  % first copy above dictionaries into userdict
  forthdict userdict copy casperdict exch copy pop
  % now enable top-down programming method
  topdown
} bind def
% vim: tabstop=8 shiftwidth=2 expandtab softtabstop=2
