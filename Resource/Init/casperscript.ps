% top-level definitions go into systemdict
/#! {{currentfile 128 string readline exch pop {exit} if} loop} bind def
/# /#! load def  % also enable # comments
/.silent -112 def  % gs_error_silent in base/gserrors.h

/forthdict 1024 dict def
forthdict begin
  % add some helpful words from FORTH, starting with `words`
  /dictwords {  % dict -
    % print to stdout all the words (keys) in the dictionary
    {pop cvx ==only ( ) =only} forall () =
  } bind def
  /words {  % -
    % print to stdout all words from all dictionaries, like FORTH
    countdictstack array dictstack {dictwords} forall
  } bind def
  /bye /quit load def  % alias Forth 'bye' to ps 'quit'
  /see {  % *not* prefix like Forth; use as `/someword see`
    {mark exch load dup mark exch ===} stopped {cleartomark ==} {pop} ifelse
    cleartomark  % necessary in case `load` was unrecognized
  } bind def
end  % forthdict

/casperdict 1024 dict def
casperdict begin
  % add some generally useful words without polluting systemdict
  /topdown {  % -
    % changes behavior of interpreter to allow topdown design
    % instead of causing /undefined errors, lets you run program at every
    % phase of development, showing a placeholder for undefined words.
    errordict begin
      /undefined {
        (\(/) print =only ( not yet defined\) ) print
      } bind def
    end
  } bind def
  /alias {  % /currentname /newname -
    % alias currentname to newname
    exch load def
  } bind def
  /strlen {  % anystring - strlen  % length to first null (\000)
    % if no nulls, entire length of string (same as `length`)
    (\000) search {3 1 roll pop pop length} {length} ifelse
  } bind def
  /append {  % stringbuffer string - combined
    % add (concatenate) string to buffer without shortening buffer
    % (a\000\000) (b) append -> (ab\000)
    1 index dup strlen  % offset to first empty place in buffer
    % stack now: buffer string buffer offset
    3 2 roll putinterval
  } bind def
  /strtruncate {  % stringbuffer - string
    % remove trailing nulls at end of stringbuffer
    0 1 index strlen getinterval
  } bind def
  /stradd {  % string1 string2 - combined
    % add (concatenate) two strings: (a) (b) stradd -> (ab)
    2 copy strlen exch strlen add string  % make new empty string
    3 2 roll append exch append
  } bind def
  /strmul {  % string multiplier - string
    % multiply a string as does Python: (a) 5 strmul -> (aaaaa)
    1 index strlen 1 index mul string  % string multiplier buffer
    exch {1 index append} repeat
    exch pop
  } bind def
  /add {  % redefine add to include stradd
    {add} stopped {stradd} if
  } bind def
  /truncate {  % redefine truncate to include strtruncate
    {truncate} stopped {strtruncate} if
  } bind def
  /add /+ alias  % allow use of `+` for `add`
  % set up `argc` and `argv` in userdict, as in C and Python.
  % as of 2023-04-19 argv0 is not visible to csbin/* programs, so we
  % need to check for it.
  % NOTE: problem is that ARGS isn't set up until after processing --,
  % so `argc` and `argv` need to be procedures
  /.argcargv {
    userdict dup /ARGS known
      {dup /ARGS get /.argv exch put}
      {/.argv [argv0] put} ifelse
    userdict dup /.argv get length /.argc exch put
  } bind def
  /argc {userdict /.argc known {.argc} {.argcargv .argc} ifelse} bind def
  /argv {userdict /.argv known {.argv} {.argcargv .argv} ifelse} bind def
end  % casperdict

/casper {  % -
  % initialize for programming with casper extensions
  % first copy above dictionaries into userdict
  forthdict userdict copy casperdict exch copy pop
  % now enable top-down programming method
  topdown
} bind def
% vim: tabstop=8 shiftwidth=2 expandtab softtabstop=2
