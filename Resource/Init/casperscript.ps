% top-level definitions go into systemdict
% NOTE: cannot use <<>> format for dicts, use `n dict def`, `begin`, `end`.
% NOTE: interpreter is languagelevel 1 at load time.
% HINT: test changes using `/usr/bin/gs -dNOSAFER -dNODISPLAY`,
% `(Resource/Init/casperscript.ps) run`
% `casper`
% `0.0 cvbool =`
% for example, before `make all install`
% NOTE: for this to work, don't do anything in this file that *presupposes*
% any casperscript extensions.
/#! {{currentfile 128 string readline exch pop {exit} if} loop} bind def
% define #, ##, and ### as stderr equivalents of =, ==, and ===
% NOTE: ghostscript buffers stderr, so we have to `flushfile` on write to it
/#only  {(%stderr) (w) file dup 3 -1 roll write=only flushfile} bind def
/#	{#only (\n) #only} bind def
/##only {(%stderr) (w) file dup 3 -1 roll write==only flushfile} bind def
/## {##only (\n) #only} bind def
/###only {(%stderr) (w) file dup 3 -1 roll write===only flushfile} bind def
/### {###only (\n) #only} bind def
/.silent -112 def  % gs_error_silent in base/gserrors.h
% PLRM recommends only allocating enough for immediate needs with `dict`
% it will grow as needed (languagelevels 2+)
% NOTE though: this does not apply here! it's languagelevel 1 at this point!
/forthdict 128 dict def
forthdict begin
  % add some helpful words from FORTH, starting with `words`
  /dictwords {  % dict -
    % print to stdout all the words (keys) in the dictionary
    {pop cvx ==only ( ) =only} forall () =
  } bind def
  /words {  % -
    % print to stdout all words from all dictionaries, like FORTH
    countdictstack array dictstack {dictwords} forall
  } bind def
  /bye /quit load def  % alias Forth 'bye' to ps 'quit'
  /see {  % *not* prefix like Forth; use as `/someword see`
    {mark exch load dup mark exch ===} stopped {cleartomark ==} {pop} ifelse
    cleartomark  % necessary in case `load` was unrecognized
  } bind def
end  % forthdict

/casperdict 256 dict def
casperdict begin
  % add some generally useful words without polluting systemdict
  /docstrings 1024 dict def  % casperscript addition
  /help { % casperscript adds context-specific help {
    count 0 eq
      {help}  % original ghostscript "help"
      {dup docstrings exch known {docstrings exch get} if}
      ifelse
    {print (\n) print flush} stopped {
      (no help for /) print 64 string cvs print (\n) print flush
    } if
  } bind def
  /docstring {  % name string - name
    % intended to be used just after /name and before function definition
    docstrings 2 index  % name string dict name
    3 -1 roll put  % bring string to TOS and store in docstrings
  } bind def
  /topdown {  % -
    % changes behavior of interpreter to allow topdown design
    % instead of causing /undefined errors, lets you run program at every
    % phase of development, showing a placeholder for undefined words.
    % NEW as of 2023-08-16: parses dot-notation names to allow for syntax
    % like `os.path.split`
    errordict /.undefined known
      {(topdown already initialized) =}
      {
        % this needs to go into always-available dictionary (userdict?)
        /.extract {  % dottedname - any flag  % for use by `topdown`
          % assume dotted name pattern is dict.dict.procedure
          % NOTE we cannot use /undefined for the thrown error
          % or it will result in an infinite loop and /stackoverflow
          mark 1 index length string 2 index exch cvs  % name to string
          dup (.) string.count 1 add array
          exch (.) string.split  % string to array
          dup 0 get cvn where not
            % need to duplicate name for .undefined signalerror to work
            {cleartomark dup /.undefined signalerror} if
          % if we reached this point, containing dict for element 0 is on stack
          exch {{cvn get} forall} stopped
            {cleartomark dup /.undefined signalerror} if
          exch pop exch pop exec
        } bind def
        errordict /.undefined errordict /undefined get put
        errordict begin
          /undefined {
            dup type /nametype eq exch dup xcheck 3 -1 roll and
              {{.extract} stopped {(\(/) print =only ( not yet defined\)) =} if}
              {pop /.undefined signalerror}
              ifelse
          } bind def
        end
      }
      ifelse
  } bind def
  /alias (  /currentname /newname -
    alias currentname to newname) docstring {
    exch load def
  } bind def
  /ctrl (  (c) - (^C)
    generate control character from given character) docstring {
    ord 32 64 or not and chr
  } bind def
  /font.size (  font - size
    guesses font size as being the x scale of the font) docstring {
    dup /FontMatrix get 0 get
    exch {/OrigFont get /FontMatrix get 0 get div} stopped
    % see PLRM `scalefont` explanation
    {pop (font ) #only ##only ( not scaled yet) # pop 1.0} if
  } bind def
  /swap ( index -
    swap TOS with item at index (before placing said index on stack---
    same as index itself works)) docstring {
    % first put the part of the stack in play into an array
    1 add array astore
    % now get the first and last elements
    dup 0 get exch dup dup length 1 sub get
    % store the final element in slot 0
    exch dup 3 -1 roll 0 exch put
    % and the first element in slot arraylength-1
    dup dup length 1 sub 4 -1 roll put
    % now put the modified array back on the stack, tossing the copy
    aload pop
    % surely there's a better way!
  } bind def
  /=stack (  -
    one-line version of pstack using ==) docstring {
    count array astore dup == aload pop
  } bind def
  /=stack /==stack alias  % for symmetry
  /===stack (  -
    =stack using ===) docstring {
    count array astore dup === aload pop
  } bind def
  /#stack (  -
    =stack, but to stderr) docstring {
    count array astore dup ## aload pop
  } bind def
  /#stack /##stack alias  % for symmetry
  /###stack (  -
    #stack using ###) docstring {
    count array astore dup ### aload pop
  } bind def
  /strlen {  % anystring - strlen  % length to first null (\000)
    % if no nulls, entire length of string (same as `length`)
    (\000) search {3 1 roll pop pop length} {length} ifelse
  } bind def
  /string.append (  stringbuffer string -
    add (concatenate) string to buffer without shortening buffer
    (a\\000\\000) (b) append -> (ab\\000)
    NOTE: must keep a reference to stringbuffer on stack or in userdict
    or it will disappear after operation) docstring {
    1 index strlen  % offset to first empty place in buffer
    % stack now: buffer string buffer offset
    exch putinterval
  } bind def
  /array.append (  array any -
    replace the first `null` element in array with `any`) docstring {
    1 index length 1 sub 0 1 3 -1 roll
    {2 index 1 index get null eq
      {exch put exit}
      {pop}
      ifelse
    }
    for
  } bind def
  /inc {  % name -
    % increments variable, e.g. `/a 1 def /a inc a =` shows `2`
    dup cvx exec 1 add def
  } bind def
  /zero {  % name -
    0 def
  } bind def
  /ord {  % numeric value of single-character string
    0 get
  } bind def
  /chr {  % single-character string from number
    1 string dup 0 4 -1 roll put
  } bind def
  % some constants that may be handy
  /WhiteSpaces (  - string
    white-space characters from table 3.1 of PLRM
    notably, \\b (backspace) is not considered whitespace,
    nor any other of the ASCII control characters) docstring
    (\000\t\n\f\r ) def
  /Space ( ) ord def
  % NOTE: maybe string functions should all have the form string.something?
  /string.clear (  string -
    empty string by replacing all characters with \\000) docstring {
    dup length string 0 exch putinterval
  } bind def
  /string.random (  length - string
    returns string with random binary contents) docstring {
    string (/dev/urandom) (r) file exch readstring pop
  } bind def
  /array.clear (  array -
    empty array by replacing all items with null) docstring {
    dup length array 0 exch putinterval
  } bind def
  /string.fromarray (  array - string
    convert array of numbers from 0 through 255 into string
    from the Guru, Don Lancaster, at https://www.tinaja.com/glib/strconv.pdf
    (he called it `makestring`)) docstring {
    dup length string dup /NullEncode filter
    3 -1 roll {1 index exch write} forall flushfile
  } bind def
  /array.fromstring (  string - array
    convert string to array, also from Don Lancaster) docstring {
    [ exch {} forall ]
  } bind def
  /array.random (  length - array
    array with random contents, numbers from 0 through 255) docstring {
    string.random array.fromstring
  } bind def
  /string.truncate {  % stringbuffer - string
    % remove trailing nulls at end of stringbuffer
    0 1 index strlen getinterval
  } bind def
  /array.truncate ( array - array
    truncate array to first `null` item) docstring {
      /nullcount 0 def
      dup
      {null eq
        {exit}
        {/nullcount inc}
        ifelse
      }
      forall
      0 nullcount getinterval
  } bind def
  /string.count (  string substring - count
    roughly equivalent to python's str.count) docstring {
    1 dict begin
    /counter zero
    dup length
      [
        % python returns len(string) + 1 in '' case
        {pop length 1 add /counter exch def}
        {ord exch {1 index eq {/counter inc} if} forall pop}
      ]
    exch {get exec} stopped {
      pop pop % get rid of array and searchstring length
      {2 copy search  % post match pre true, or string false
        {/counter inc pop pop 3 -1 roll pop exch}
        {pop pop pop exit}
        ifelse
      } loop
    } if
    counter
    end
  } bind def
  /string.split (  array string delimiter - array
    similar to python's str.split, but treats all [(\\000)-( )]
    characters as default whitespace) docstring {
    dup length 0 gt
      { % delimiter is not empty string, need to search for it
        {2 copy search
          {% post match pre true
            5 index exch array.append pop 3 -1 roll pop exch
          }
          {% string false
            3 index exch array.append
            pop pop exit
          }
          ifelse
        }
        loop
      }
      { % delimiter is empty string, so first change all sub-() to ()
        pop dup length 1 sub 0 1 3 -1 roll
        {dup 2 index exch get Space le
          {1 index exch 0 put}
          {pop}
          ifelse
        } for
        % now call recursively, but using (\000) as delimiter
        (\000) string.split
      }
      ifelse
    array.truncate  % get rid of any nulls following string contents
  } bind def
  /string.join (  array delimiter - string
    join array of strings with delimiter to create string) docstring {
    1024 dup mul string  % buffer for string creation
    2 index length 2 sub 0 1 3 -1 roll  % set up for `for` loop
      { % array delimiter buffer arrayindex
        3 index exch get 1 index exch string.append  % array element appended
        dup 2 index string.append  % delimiter appended
      }
      for
    3 1 roll pop  % discard delimiter
    dup length dup 0 gt
      {
        1 sub get  % grab final string from array
        1 index exch string.append  % add to buffer
      }
      {pop pop}
      ifelse
    %(stack before string.truncate: ) #only #stack
    string.truncate  % get rid of trailing null bytes
  } bind def
  /string.iscapital (  string - iscapital
    somewhat similar to Python str.istitle()
    but only checks first letter of first word
    and only known to work with ASCII characters) docstring {
    0 get dup 32 not and eq
  } bind def
  /array.last (  array - any
    returns final element of array.
    will /rangecheck on empty array) docstring {
    dup length 1 sub get
  } bind def
  /string.isheader (  string - isheader
    similar to Python str.istitle()
    but only checks first and final words for capitalization,
    and ensures no periods (.) in it) docstring {
    dup ( ) string.count 1 add array 1 index () string.split
    dup array.last string.iscapital exch 0 get string.iscapital and
    exch (.) string.count 0 eq and
  } bind def
  /stradd {  % string1 string2 - combined
    % add (concatenate) two strings: (a) (b) stradd -> (ab)
    2 copy strlen exch strlen add string  % make new empty string
    dup 4 -1 roll string.append dup 3 -1 roll string.append
  } bind def
  /strmul {  % string multiplier - string
    % multiply a string as does Python: (a) 5 strmul -> (aaaaa)
    1 index strlen 1 index mul string  % string multiplier buffer
    exch {dup 2 index string.append} repeat
    exch pop
  } bind def
  /add {  % redefine add to include stradd
    {add} stopped {stradd} if
  } bind def
  /mul {  % redefine mul to include strmul
    {mul} stopped {strmul} if
  } bind def
  /truncate {  % redefine truncate to include string.truncate
    {truncate} stopped {string.truncate} if
  } bind def
  /strcopy {  % string - copyofstring
    % true copy as opposed to a reference
    dup length string copy
  } bind def
  /add /+ alias  % allow use of `+` for `add`
  /sub /- alias  % allow use of `-` for `sub`
  /mul /* alias  % allow use of `*` for `mul`
  % cannot use `/` for `div`, nor `//` for `idiv`, until we hijack the parser
  % for the same reason we cannot use `%` for `mod`
  /reversed {  % for strings and arrays
    % we make sure to make a copy with strcopy so as not to mess with
    % the original; we were reversing argv[0] previously!
    strcopy reverse
  } bind def
  /reverse {  % see comments for `reversed`
    % this is an *in-place* reverse, like Python!
    % however, it leaves a copy on the stack.
    dup length 1 - dup 1 + 2 idiv 1 - 0 1 3 -1 roll {  % array length-1 control
      % e.g. abcxyz 5 0
      %(pstack at start of `for` loop, e.g. abcxyz 5 0:) = pstack
      3 copy 3 copy - get 4 1 roll  % abcxyz 5 0 z abcxyz 5 0
      %(pstack after first get, e.g. abcxyz 5 0 z abcxyz 5 0:) = pstack
      exch pop get  % abcxyz 5 0 z a
      %(should be e.g. abcxyz 5 0 z a:) = pstack
      3 index 3 index - exch 5 index 3 1 roll put
      %(should be e.g. abcxya 5 0 z:) = pstack
      3 index 3 1 roll put  % zbcxya 5
      %(should be e.g. zbcxya 5:) = pstack
    } for pop  % drop length-1
  } bind def
  /cvbool {  % something - boolean
    % convert anything (well, some things) to boolean
    3 dict begin
    /nulltype {pop false} def
    /integertype {0 ne} def
    /realtype {0 ne} def
    dup type dup currentdict exch known
      {currentdict exch get exec}
      {pop length 0 ne}
      ifelse
    end
  } bind def
  /pagewidth {currentpagedevice /PageSize get 0 get} bind def
  /pageheight {currentpagedevice /PageSize get 1 get} bind def
  /pagesize {  % - pagewidth pageheight
    % get current page size
    % NOTE: original casperscript got this backwards!
    currentpagedevice /PageSize get dup 0 get exch 1 get
  } bind def
  /.import {  % /dictname -
    % unconditionally import dict
    2 dict begin  % for local variables
    /dottedname 1 index 64 string cvs (.) + def  % dotted name of imported dict
    /filename dottedname (cs) + def  % we look for file with .cs extension
    dup 5 dict def load
    begin filename runlibfile end  % loads file into dict of same name
    end
  } bind def
  /import {  % /dictname reimport -
    % import the dict
    % does nothing if dict already present in currentdict and reimport is false
    % gives error if dictname present but not a dict
    currentdict 2 index known  % stack: /dictname reimport known
      {  % already in dict, so make sure correct type
        1 index load type /dicttype eq
          {
            {(reimporting) # .import}
            {#only ( already imported) #}
            ifelse
          }
          {
            1 index dup #only ( already exists and is not a dict) #
            /typecheck signalerror
          }
          ifelse
      }
      {pop .import}  % not already in dict
      ifelse
  } bind def

  %(languagelevel: ) print /languagelevel where {pop languagelevel} {1} ifelse =
  %(version: ) print version =
  /os 16 dict def
  os begin  % os attributes for GNU/Linux assumed
    /path null def  % fill in later with posixpath
    /name (posix) def
    /curdir (.) def
    /pardir (..) def
    /sep (/) def
    /extsep (.) def
    /altsep (null) def
    /pathsep (:) def
    /linesep (\n) def
    /devnull (/dev/null) def
  end  % os
  /posixpath 16 dict def
  posixpath begin
    % path functions expected to work on posix (and URL paths)
    /split {  % pathspec - dirspec namespec; e.g. /path/to/xyz.ps
      reversed os /sep get search  % ot/htap/ / sp.zyx
        {exch pop reversed exch reversed exch}
        {reversed () exch}
      ifelse
      %(pstack after posixpath.split:) = pstack
    } bind def
    /splitext {  % pathspec.ext - pathspec .ext
      % NOTE that this won't work with, e.g. /path/to.some/filewithnoext,
      % it will return /path/to .some/filewithnoext
      % so, one should always `split` before `splitext`
      reversed os /extsep get search  % zyx/ot/htap/ . sp
        {reversed + exch reversed exch}  % /path/to/xyz .ps
        {reversed ()}  % pathwithnoext ''
      ifelse
      %(pstack after posixpath.splitext:) = pstack
    } bind def
    /exists {  % pathspec - flag
      mark exch status {cleartomark true} {pop false} ifelse
    } bind def
  end  % posixpath
  os /path posixpath put
  % NOTE: remember that only a minimal `sys.argv` is defined at this point,
  % created by `casper`, % run at processing of `-C`.
  % A script is run only after processing `--`, and that is where the full
  % `sys.argv` is defined.
  /scriptname {
    sys.argv 0 get os /path get dup /split get 3 -1 roll exch exec
    %(scriptname after split:) = pstack
    %(sys.argv after split:) = sys.argv ==
    exch pop exch /splitext get exec
    %(scriptname after splitext:) = pstack
    %(sys.argv after splitext:) sys.argv ==
    pop
    %(pstack after scriptname:) = pstack
  } bind def
end  % casperdict

/casper {  % -
  % initialize for programming with casper extensions
  % first copy above dictionaries into userdict
  forthdict userdict copy casperdict exch copy pop
  % put a minimal `sys.argv` into userdict in case a script is not being run
  userdict /sys.argv {[argv0] put} stopped {pop [(gs)] put} if
  userdict /sys.argc 1 put
  % now enable top-down programming method
  topdown
} bind def
% vim: tabstop=8 shiftwidth=2 expandtab softtabstop=2
