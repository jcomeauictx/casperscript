#! bin/cs -S -dBATCH -dNOPAUSE -C --
% visual diff two pnm files

/bits <<  % translate maxvalue into bits per sample
  1 1
  255 8
>> def

/decode <<  % Pn type into Decode matrix
  /P1 [0 1]
  /P2 [0 1]
  /P3 [0 1 0 1 0 1]
>> def

/colorspaces <<  % Pn type into colorspace
  /P1 /DeviceGray
  /P2 /DeviceGray
  /P3 /DeviceRGB
>> def

/pnm <<  % valid type 1 image dict once fleshed out
  /ImageType 1
  /Height 0
  /Width 0
  /ImageMatrix [/w 0 0 /-h 0 /h]  % placeholder for top-bottom left-right data
  /MultipleDataSources false  % optional (default) but let's be explicit
  /DataSource null  % replace with input stream
  /BitsPerComponent 1  % default for P1
  /Decode [0 1]  % map colors into range 0 to 1 ([0 1 0 1 0 1] for RGB)
  /Interpolate false  % another optional, default false
>> def

/comment (#) 0 get def  % comment introducer

/readpnm {  % filename - pnminstance colorspace
  % read PNM file into dict
  % we confine ourselves to gs-created pnm files, which only have a single
  % whole-line comment on 2nd line. this won't work with end-of-line comments.
  pnm dup length dict copy /instance exch def  % new instance of pnm dictionary
  (r) file /infile exch def  % open file and store handle in `infile`.
  /buffer 1024 string def  % hopefully enough for any PNM line length
  /pnmtype infile token pop cvlit def  % /P1, /P2, or /P3
  instance /Decode decode pnmtype get put
  /colorspace colorspaces pnmtype get def
  % read and discard the expected comment, throw error on failure.
  infile buffer readline pop 0 get comment ne {
    (Not gs-created pnm file) = /valueerror signalerror
  } if
  instance /Width infile token pop cvi dup /width exch def put
  instance /Height infile token pop cvi dup /height exch def put
  instance /ImageMatrix get dup dup  % we're going to overwrite the /w etc.
    0 width put
    3 height neg put
    5 height put
  pnmtype (P1) ne {  % P2 and P3 have an extra line, max value
    instance /BitsPerComponent bits infile token pop cvi get put
  } if
  % read in the image data from the same file
  % convert ASCII numbers to bytestring on the fly
  /asciifilter {  % infile buffer - infile buffer bytestring
    % convert (255 0 1 255) to (\377\000\001\377)
    2 copy  % keep infile and buffer for reuse
    readline pop 0 1 index {token  % stack (255 0 1 255) 0 (0 1 255) 255 true
      {3 index 2 index 3 -1 roll put exch 1 add exch}
      % otherwise, stack (\377\000\001\3770 1 255) 4 false
      {string copy exit} ifelse
      (stack inside loop:) = pstack
    } loop
    (stack outside loop:) = pstack
  } bind def
  instance /DataSource {infile buffer asciifilter} bind put
  /generator (/dev/urandom) (r) file def  % until we figure out filter
  /bytecount 0 def  % for keeping track of bytes read
  instance /DataSource {generator 24 string readstring pop (stack: ) = pstack} bind put
  instance dup (instance: ) print === colorspace
} bind def

/vdiff {  % filename1 filename2 sidebyside -
  % generate pnm of differences between two pnm files
  % (vdiff called, stack:) = pstack
  /sidebyside exch def
  /filename2 exch def
  /filename1 exch def
  filename1 readpnm setcolorspace 100 100 moveto image 9 sleep
} bind def
(    file1 = open(filename1, 'r')
    file2 = open(filename2, 'r')
    pnmtypes = (get(file1).strip(), get(file2).strip())
    if pnmtypes[0] != pnmtypes[1]:
        raise ValueError('Different PNM types %s and %s' % pnmtypes)
    logging.debug('pnmtypes: %s', pnmtypes)
    dimensions = (get(file1).strip(), get(file2).strip())
    if dimensions[0] != dimensions[1]:
        raise ValueError('Different dimensions %s and %s' % dimensions)
    dimensions = tuple(map(lambda s: tuple(map(int, s.split())), dimensions))
    logging.debug('dimensions: %s', dimensions)
    expected_length = int.__mul__(*dimensions[0]) * MULTIPLIER[pnmtypes[0]]
    logging.debug('expected file length: %d', expected_length)
    if pnmtypes[0] == 'P1':
        maxvalues = ('1', '1')
    else:
        maxvalues = (get(file1).strip(), get(file2).strip())
    logging.debug('maxvalues: %s', maxvalues)
    if maxvalues[0] != maxvalues[1]:
        raise ValueError('incompatible max values %s', maxvalues)
    maxvalues = tuple(map(int, maxvalues))
    data = [[], []]
    while True:
        try:
            raw1, raw2 = get(file1).strip(), get(file2).strip()
            if ' ' in raw1:
                raw1, raw2 = raw1.split(), raw2.split()
            data[0] += list(map(int, raw1))
            data[1] += list(map(int, raw2))
        except StopIteration:
            break
    lengths = tuple(map(len, data))
    if lengths[0] != lengths[1]:
        raise ValueError('Different lengths: %s' % lines)
    if lengths[0] != expected_length:
        raise ValueError('Unexpected length: %d != %d' %
                         (lengths[0], expected_length))
    imagebytes = (bytes(data[0]), bytes(data[1]))
    image1 = Image.frombytes(MODE[pnmtypes[0]], dimensions[0], imagebytes[0])
    image2 = Image.frombytes(MODE[pnmtypes[1]], dimensions[1], imagebytes[1])
    merged = Image.frombytes(MODE[pnmtypes[0]], dimensions[0],
                             merge(*data, maxvalues[0]))
    if sidebyside:
        image1.show()
        image2.show()
    else:
        merged.show()

def merge(data0, data1, maxvalue):
    '''
    return difference, as bytes, between two arrays of numbers
    '''
    merged = [maxvalue - abs(data1[n] - data0[n]) for n in range(len(data0))]
    return bytes(merged)
) pop

argv dup 1 get exch dup 2 get exch {3 get} stopped {pop pop false} if vdiff
